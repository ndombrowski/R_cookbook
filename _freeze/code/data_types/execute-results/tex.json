{
  "hash": "f01dcc32fe7549cf65320728dcd7db3a",
  "result": {
    "markdown": "---\nexecute:\n    eval: true\n\ndf-print: paged\n---\n\n\n\n# Data types\n\n\n\n::: {.cell}\n\n:::\n\n\n\nWhen programming, data,values,etc. are stored in different ways: \n\nR has 6 atomic classes. Below you can find each class with an example\n\n- character = \"hello\"\n- numeric (real or decimal) = 3, 14, ....\n- logical = TRUE\n- complex = 1+4i\n- integer = 2 (Must add a L at end to denote integer)\n- double = a number class, like the integer but with double precision floating points\n\nHere, is a quick example, how we can find out some things about our objects using:\n\n- - ``c()``= a function that will create a vector (a one dimensional array) and in our case store 3 numbers. We need to use this every time we deal with more than one number, character, etc....\n- ``class()`` = what class is our data?\n- ``length()`` = how long is our data?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create some objects\ncharacter_object <- \"dataset\"\nnumber_object <- c(1,4,5)\n\n#asking with what type we work\nclass(character_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(number_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#ask how long our objects are\nlength(character_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nlength(number_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\n## Data structures\n\nThere are many types of data structures, the most frequently used ones being:\n\n* Vectors\n* Factors\n* Matrices\n* Lists\n* Data frames\n\nCertain operations only work on certain kind of structures, therefore, it is important to know what kind of data we are working with.\n\nIn R, you do not need to specify the type of data a variable will receive beforehand. \nYou simply do the assignment, R will create a so called R-Object and assign a data type automatically. \n\n\n### Vectors\n\nA vector is a collection of items of the same type (i.e characters, numbers). You can read in numbers and characters into the same vector, however, the number will be then seen as a character if you mix different classes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#lets create a random vector\na_vector <- c(2, 3, 5, 7, 1) \n\n#show the vector we just created\na_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 5 7 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#asking how long your vector is\nlength(a_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n\n\n#### Vector indexing\n\nIf we want to only retrieve part of the data stored in a vector we can create a subset using the index as shown below.\n\n- square brackets [] = allow us to retrieve certain elements of a vector, i.e. [3] retrieves the 3rd element\n- we can combine ``c()`` and [] if we want to retrieve several elements of a vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#retrieve the third element stored in a vector\na_vector[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#retrieve the 1st and 3rd element by combining ``c()`` and []\na_vector[c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#retrieve the 1-3rd element\na_vector[c(1:3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#we can also add vectors of the same length together\nx <- c(1,2,3,4)\ny <- c(1,2,3,4)\n\n#and now we can combine our vectors\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 8\n```\n:::\n:::\n\n\n\nBeware: If we add two vectors of different length, the shorter vector is duplicated. This only works if the shorter vector is proportional to the longer one\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#adding vectors of different lengths\nx <- c(1,2)\ny <- c(1,2,3,4)\n\n#and now we can combine our vectors\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 4 6\n```\n:::\n:::\n\n\n\nAnother way to extend vectors is:\n\n- ``append()`` --> Add elements to a vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#add another datapoint to our vector\na_vector <- append(a_vector, 13)\na_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  5  7  1 13\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#add +1 to all our four numbers\na_vector <- a_vector + 1\na_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  4  6  8  2 14\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#remove the first element of our vector\na_vector <- a_vector[-1]\na_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  6  8  2 14\n```\n:::\n:::\n\n\n\nWe not only can extract the nth element but if we have header names then we can also use these to retrieve data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a vector and give it names (i.e. for counts from some microbes)\nx <- c(300, 410, 531)\nnames(x) <- c(\"Ecoli\",\"Archaeoglobus\",\"Ignicoccus\")\n\n#check how our data looks\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Ecoli Archaeoglobus    Ignicoccus \n          300           410           531 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#now we can retrieve part of the vector using the names\nx[c(\"Ecoli\",\"Ignicoccus\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Ecoli Ignicoccus \n       300        531 \n```\n:::\n:::\n\n\n\n\n#### Changing vectors\n\nWe can also change elements in our vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a vector\nx <- 1:10\n\n#change the second last positions to 5 and 9\nx[9:10] <- c(5,9)\n\n#check if this worked\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 3 4 5 6 7 8 5 9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#we can not only add things, we can also remove this using the minus/**-** symbol\nx[-3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 4 5 6 7 8 5 9\n```\n:::\n\n```{.r .cell-code}\n#if we want to remove more than one thing we can use the **c()**\nx[-(4:10)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n\n\n### Matrix\n\nMatrices are the R objects in which the elements are arranged in a two-dimensional rectangular layout. They contain elements of the same type. Although you can construct matrices with characters or logicals, matrices are generally used to store numeric data. \n\nThe basic syntax for creating a matrix is:\n\n**matrix(data, nrow, ncol, byrow, dimnames)**\n\n- data: input vector whose components become the data elements from the matrix.\n- dnrow: number of rows to be created.\n- dncol: number of columns to be created.\n- dbyrow: logical. If FALSE,(the default) the matrix is filled by columns, otherwise the matrix is filled by rows.\n- ddimnames: A <e2><80><98>dimnames<e2><80><99> attribute for the matrix: NULL or a list of length 2 giving the row and column names respectively.\n\nIn contrast in a data frame (see below) the columns contain different types of data, while in a matrix all the elements are the same type of data. A matrix in R is like a mathematical matrix, containing all the same type of thing (usually numbers). R often but not always can use dataframes and a matrix used interchangably.\n\n* Individual elements in a matrix can be printed using **[row,column]**. For example **[2,3]** would pull out the value in the 2nd ROW and third COLUMN.\n\n- ```dim()``` is extremely useful to control whether our data was transformed correctly during different operations. For example, after we merge two files we would like to know that they still have the same number of rows as when we started the analysis. Same if we remove for example 10 samples, then we want to make sure that this is indeed what happened.\n- ``head()`` is another useful function to check the first rows of a larger matrix (or dataframe)\n- ``tail()`` same as head but showing the last rows\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#define our row and column names\nrow.names = c(\"row1\", \"row2\", \"row3\", \"row4\")\ncol.names = c(\"col1\", \"col2\", \"col3\")\n\n#create our matrix (check the help function to see what is happening)\nmatrix_A <- matrix(c(3:14), nrow = 4, byrow = T, dimnames = list(row.names,col.names))\n\n#check how our matrix looks like\nmatrix_A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col2 col3\nrow1    3    4    5\nrow2    6    7    8\nrow3    9   10   11\nrow4   12   13   14\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#print the value in the 2row and 3rd column\nmatrix_A[2,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#print the values in the 3rd column\nmatrix_A[,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrow1 row2 row3 row4 \n   5    8   11   14 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#print everything except the 1st row\nmatrix_A[-1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col2 col3\nrow2    6    7    8\nrow3    9   10   11\nrow4   12   13   14\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#print everything except the 2nd column\nmatrix_A[,-2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col3\nrow1    3    5\nrow2    6    8\nrow3    9   11\nrow4   12   14\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#see the dimensions of matrix, i.e. the nr of rows and columns\ndim(matrix_A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#check the first rows of our matrix, since our data is small, everything is shown\nhead(matrix_A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     col1 col2 col3\nrow1    3    4    5\nrow2    6    7    8\nrow3    9   10   11\nrow4   12   13   14\n```\n:::\n:::\n\n\n\n\n\n### Lists\n\nSometimes you need to store data of different types. For example, if you are collecting cell counts, you might want to have cell counts (numeric), the microbes investigated (character), their status (logical, with TRUE for alive and FALSE for dead, .... This kind of data can be stored in lists. Lists are the R objects which contain elements of different types (numeric, strings, vectors, even another list, or a matrix).\n\nA list is created using the list() function.\n\nFor example, the following variable x is a list containing copies of three vectors n, s, b.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#define our vectors\nn = c(20, 30, 50) \ns = c(\"Ecoli\", \"Archaeoglobus\", \"Bacillus\") \nb = c(TRUE, FALSE, TRUE) \n\n#combine the vectors in a list\nour_list = list(counts=n, strain=s, status=b) \n\n#show our list\nour_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$counts\n[1] 20 30 50\n\n$strain\n[1] \"Ecoli\"         \"Archaeoglobus\" \"Bacillus\"     \n\n$status\n[1]  TRUE FALSE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#sublist the second element in a list\nour_list[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$strain\n[1] \"Ecoli\"         \"Archaeoglobus\" \"Bacillus\"     \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#retrieve the 2nd and 3rd member of our list\nour_list[c(2, 3)] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$strain\n[1] \"Ecoli\"         \"Archaeoglobus\" \"Bacillus\"     \n\n$status\n[1]  TRUE FALSE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#we can also retrieve elements of a list if we know the name using two different ways:\nour_list$strain\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ecoli\"         \"Archaeoglobus\" \"Bacillus\"     \n```\n:::\n\n```{.r .cell-code}\nour_list[[\"strain\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ecoli\"         \"Archaeoglobus\" \"Bacillus\"     \n```\n:::\n:::\n\n\n\nIn the last example we use the ``$`` dollar symbol to extract data, i.e. to extract variables in a dataset (a matrix, list, dataframe). I.e. above the data we want to access is 'our_list' and the variable we want to extract is the strain.\n\n\n### Dataframes\n\nDataframes are tables in which each column contains values of one variable type and each row contains one set of values from each column. \nYou can think of a data frame as a list of vectors of equal length.\nMost of our data very likely will be stored as dataframes.\n\nA Dataframe usually follows these rules:\n\n- The top line of the table, called the header, contains the column names. \n- Column names (i.e. the header of our data) should be non-empty (if they are, R provides the object with default values).\n- Row names should be unique\n- Each column should contain the same number of data items\n- Each horizontal line after the header is a data row, which begins with the name of the row, and then followed by the actual data. \n- Each data member of a row is called a cell.\n\nImportantly, most of the things we have learned before, i.e. how to subset data, apply here too.\n\nThe growth data that we have read into R will be used to explain how dataframes work.\n\n\n#### Viewing data Dataframes\n\n- We can use the brackets as before to extract certain rows or columns.\n- We can use the dollar sign to again extract information as long as we know the column names. I.e. now we want to access the shoot fresh weight (FW_shoot_mg) in our 'growth_data' dataframe.\n- ``colnames()`` allows us to access the column names, i.e. the headers\n- ``rownames()`` allows us to access the rownames of our data (usually these are numbered if not specified otherwise while reading the table)\n- ``dim()`` allows us to check the dimensions (i.e. the number of rows and columns). This is useful to regullary check, especially if we modified our data somehow. \n- ``head()`` shows the first rows of our dataframe\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#view our table\nhead(growth_data)\n```\n\n::: {.cell-output-display}\n\\begin{tabular}{l|l|l|r|r}\n\\hline\nSampleID & Nutrient & Condition & FW\\_shoot\\_mg & Rootlength\\\\\n\\hline\nnoP & noP & MgCl & 10.26 & 5.931015\\\\\n\\hline\nnoP & noP & MgCl & 6.52 & 5.743447\\\\\n\\hline\nnoP & noP & MgCl & 12.17 & 6.834720\\\\\n\\hline\nnoP & noP & MgCl & 11.37 & 6.742735\\\\\n\\hline\nnoP & noP & MgCl & 9.80 & 6.736886\\\\\n\\hline\nnoP & noP & MgCl & 3.75 & 4.236349\\\\\n\\hline\n\\end{tabular}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#check how many rows and columns our data has\ndim(growth_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 105   5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract the data from the 2nd row\ngrowth_data[2,]\n```\n\n::: {.cell-output-display}\n\\begin{tabular}{l|l|l|l|r|r}\n\\hline\n  & SampleID & Nutrient & Condition & FW\\_shoot\\_mg & Rootlength\\\\\n\\hline\n2 & noP & noP & MgCl & 6.52 & 5.743447\\\\\n\\hline\n\\end{tabular}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract the first three columns\nhead(growth_data[,1:3])\n```\n\n::: {.cell-output-display}\n\\begin{tabular}{l|l|l}\n\\hline\nSampleID & Nutrient & Condition\\\\\n\\hline\nnoP & noP & MgCl\\\\\n\\hline\nnoP & noP & MgCl\\\\\n\\hline\nnoP & noP & MgCl\\\\\n\\hline\nnoP & noP & MgCl\\\\\n\\hline\nnoP & noP & MgCl\\\\\n\\hline\nnoP & noP & MgCl\\\\\n\\hline\n\\end{tabular}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract a column of our data using the column name\nhead(growth_data$Condition)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"MgCl\" \"MgCl\" \"MgCl\" \"MgCl\" \"MgCl\" \"MgCl\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#print our headers\ncolnames(growth_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SampleID\"    \"Nutrient\"    \"Condition\"   \"FW_shoot_mg\" \"Rootlength\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#get the dimensions\ndim(growth_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 105   5\n```\n:::\n:::\n\n\n\nWhen we print the rownames, we see that we have numbers from 1-105. When reading in a table into R it is the default behaviour how rownames are generated. As a general rule, if you want o have other rownames, these must be unique.\n\n\n#### Adding new columns to Dataframes\n\nBelow is a very basic way to add a new column (we name it newColumn) and fill all rows with the word `comment`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#expand a dataframe, functions data.frame or cbind (or see below)\ngrowth_data$newColumn <- \"comment\"\n\n#check if that worked\nhead(growth_data)\n```\n\n::: {.cell-output-display}\n\\begin{tabular}{l|l|l|r|r|l}\n\\hline\nSampleID & Nutrient & Condition & FW\\_shoot\\_mg & Rootlength & newColumn\\\\\n\\hline\nnoP & noP & MgCl & 10.26 & 5.931015 & comment\\\\\n\\hline\nnoP & noP & MgCl & 6.52 & 5.743447 & comment\\\\\n\\hline\nnoP & noP & MgCl & 12.17 & 6.834720 & comment\\\\\n\\hline\nnoP & noP & MgCl & 11.37 & 6.742735 & comment\\\\\n\\hline\nnoP & noP & MgCl & 9.80 & 6.736886 & comment\\\\\n\\hline\nnoP & noP & MgCl & 3.75 & 4.236349 & comment\\\\\n\\hline\n\\end{tabular}\n:::\n:::\n\n\n\nThere are more sophisticated ways to add columns based on conditions or even merge dataframes. Some of these we will discuss later.\n\n\n## Check the structure of our data\n\nIf we read in our own data, we should check as what type of class our table is stored. We have several ways to do this:\n\n- ``class()`` = determines as what kind of object is stored\n- ``str()`` = display the internal structure of an R object. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#check what kind of data we have:\nclass(growth_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#check how are different parts of our data stored?\nstr(growth_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t105 obs. of  6 variables:\n $ SampleID   : chr  \"noP\" \"noP\" \"noP\" \"noP\" ...\n $ Nutrient   : chr  \"noP\" \"noP\" \"noP\" \"noP\" ...\n $ Condition  : chr  \"MgCl\" \"MgCl\" \"MgCl\" \"MgCl\" ...\n $ FW_shoot_mg: num  10.26 6.52 12.17 11.37 9.8 ...\n $ Rootlength : num  5.93 5.74 6.83 6.74 6.74 ...\n $ newColumn  : chr  \"comment\" \"comment\" \"comment\" \"comment\" ...\n```\n:::\n:::\n\n\n\nWe see that\n\n- our data is stored in a dataframe\n- that the data stored in different formats, i.e. numeric and characters\n- the first 3 columns are stored in something we call a factor.\n\n\n## Factors\n\nFactors are data objects that are used to represent categorical data and store it in its different levels. \nThey are an important class for statistical analysis and for plotting.\nFactors are stored as integers, and have labels associated with these unique integers. \nOnce created, factors can only contain a pre-defined set values, known as levels. By default, R always sorts levels in alphabetical order. \n\n- ``factor()`` allows us to create our own factor\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#lets make a vector\nNutrients <- c(\"P\", \"P\", \"noP\", \"noP\")\n\n#lets make our own simple factor\nNutrients_factor <- factor(c(\"P\", \"P\", \"noP\", \"noP\"))\n\n#lets compare the vector and factor we generated\nNutrients\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"P\"   \"P\"   \"noP\" \"noP\"\n```\n:::\n\n```{.r .cell-code}\nNutrients_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] P   P   noP noP\nLevels: P noP\n```\n:::\n:::\n\n\n\nWhen we check our factor, we see that R assigns one level to ``P`` and another level to ``noP``. \nWe can also see, that R sorts the levels in an alphabetical way, even though in the initial code we first had P before noP.\n\n\n### Checking the behaviour of factors\n\nNow, lets check how factors behave.\n\n- ``levels()`` = only prints the levels of a given factor. We can also run this on any column of our dataframe.\n- ``nlevels()`` = check how many levels we have.\n- While factors look (and often behave) like character vectors, they are actually integers under the hood, and you need to be careful when treating them like strings. We can test this by looking at what type of object we generated.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#only print the levels\nlevels(Nutrients_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"P\"   \"noP\"\n```\n:::\n\n```{.r .cell-code}\nlevels(growth_data$Condition)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#check how many levels we have\nnlevels(Nutrients_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#what class do we have\nclass(Nutrients_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(Nutrients_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n\n### Ordering factor levels\n\nFor some things, the order of things might matter and then we need to order the factors ourselves.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#check our levels\nlevels(Nutrients_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"P\"   \"noP\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#reorder levels\nNutrients_factor_reordered <- factor(Nutrients_factor, levels = c(\"P\", \"noP\"))\n\n#check our levels\nlevels(Nutrients_factor_reordered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"P\"   \"noP\"\n```\n:::\n:::\n\n\n\n\n### Converting factors\n\nSometimes you need to explicitly convert factors to either text or numbers. Or numbers to characters, etc.\nTo do this, you use the functions ``as.character()`` or ``as.numeric()``.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#convert our factor to a character\nNutrients_characters <- as.character(Nutrients_factor)\nNutrients_characters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"P\"   \"P\"   \"noP\" \"noP\"\n```\n:::\n:::\n",
    "supporting": [
      "data_types_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{\"knit_meta_id\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]}},\"value\":[{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"booktabs\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"longtable\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"array\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"multirow\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"wrapfig\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"float\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"colortbl\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"pdflscape\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"tabu\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"threeparttable\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"threeparttablex\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"ulem\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"normalem\"]},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"makecell\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"options\",\"extra_lines\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"latex_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"xcolor\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"}]}]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}